---

title: 浏览器工作原理(二)
date: 2022-08-31
---​

### 一、渲染器进程的内部工作

​ 渲染器进程负责选项卡内发生的所有事情。在渲染器进程中，主线程处理我们发送给用户的大部分前端代码。如果我们还使用了 Web Worker 或 Service Worker，那我们的 JavaScript 的某些部分由工作线程处理。合成器和光栅线程也在渲染器进程内部运行，以高效、流畅地渲染页面。

​ 渲染器进程的核心工作是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页。

#### 1、解析（Parse）

**1）DOM 的构建**

​ 当渲染器进程接收到导航的提交消息并开始接收 HTML 数据时，主线程开始解析文本字符串 (HTML) 并将其转换为文档对象模型( DOM )。DOM 是浏览器对页面的内部表示。

**2）子资源加载**

​ 网站通常使用图像、CSS 和 JavaScript 等外部资源。这些文件需要从网络或缓存中加载。主线程可以在解析构建 DOM 的过程中找到它们时一一请求，但为了加快速度，“预加载扫描器”是会同时运行的。

**3）JavaScript 可以阻止解析**

​ 当 HTML 解析器找到一个 script 标签时，它会暂停 HTML 文档的解析，并且必须加载、解析和执行 JavaScript 代码。这是因为``因为 JavaScript 可以通过改变整个 DOM 结构之类的东西来改变文档的结构，例如 document.write()方法。所以 HTML 解析器必须等待 JavaScript 运行才能恢复对 HTML 文档的解析。

#### 2、加载资源(Load resource)

​ 前端开发人员可以通过多种方式向浏览器发送提示，以便更好地加载资源。如果 JavaScript 不使用 document.write()，我们可以添加 async 或 defer 属性到 script 标记。然后浏览器异步加载和运行 JavaScript 代码，并且不会阻止解析。

#### 3、样式计算(style calculation)

​ 拥有 DOM 不足以改变页面的外观，因为我们可以在 CSS 中设置页面元素的样式。主线程解析 CSS 并确定每个 DOM 节点的计算样式。这是关于基于 CSS 选择器将哪种样式应用于每个元素的信息。即使我们不提供任何 CSS，每个 DOM 节点也有一个计算样式。h1 标签显示得比 h2 标签大，并且为每个元素定义了边距。这是因为浏览器有一个默认样式表。常常我们会不引入 css，来检查自身页面在"裸跑"的情况下的语义化如何

#### 4、布局(layout)

​ 现在渲染器进程知道文档的结构和每个节点的样式，但这还不足以渲染页面。举个例子，我们在描述一个画面：“有一个大红色圆圈和一个小蓝色方块”，仅仅这些条件并不能让其他知道这个画面的确切外观。布局是寻找元素几何形状的过程。主线程遍历 DOM 和计算样式，并创建包含 xy 坐标和边界框大小等信息的布局树。布局树可能类似于 DOM 树的结构，但它只包含与页面上可见内容相关的信息。

​ 确定页面的布局是一项比较有挑战的任务。即使是最简单的页面布局，比如从上到下的块流，也必须考虑字体有多大以及在哪里换行，因为这些会影响段落的大小和形状；然后影响下一段需要的位置。

​ CSS 可以使元素浮动到一侧，掩盖溢出项，改变书写方向。可以想象，这个布局阶段任务艰巨。在 Chrome 中，整个工程师团队都在处理布局。

#### 5、绘制(paint)

​ 拥有 DOM、样式和布局仍然不足以呈现页面。假设我们正在尝试复制一幅画。我们已经知道元素的大小、形状和位置，但我们仍然必须判断绘制它们的顺序。

​ 例如，`z-index`可能为某些元素设置，在这种情况下，按照 HTML 中编写的元素顺序绘制将导致不正确的呈现。

​ 在绘制步骤中，主线程遍历布局树以创建绘制记录。绘画记录是“先背景，后文字，后矩形”的绘画过程的记录。如果使用过 JavaScript 在 canvas 上绘制元素，那么对这个过程很熟悉。

​ 在渲染过程中要掌握的最重要的事情是，在每个步骤中，前一个操作的结果都用于创建新数据。例如，如果布局树发生变化，则需要为文档的受影响部分重新生成绘制顺序。

​ 如果我们要为元素设置动画，浏览器必须在每一帧之间运行这些操作。我们的大多数显示器每秒刷新屏幕 60 次 (60 fps)；当我们在每一帧都在屏幕上移动物体时，动画对人眼来说会显得很流畅。但是，如果动画错过了中间的帧，那么页面将出现卡顿。

#### 6、合成(compositing)

**1）如何合成**

​ 既然浏览器知道了文档的结构、每个元素的样式、页面的几何形状以及绘制顺序，那么它是如何绘制页面的呢？将此信息转换为屏幕上的像素称为光栅化。

​ 也许处理这个问题的一种天真的方法是在视口内光栅化部分。如果用户滚动页面，则移动光栅框架，并通过光栅更多来填充缺失的部分。这就是 Chrome 在首次发布时处理光栅化的方式。然而，现代浏览器运行一个更复杂的过程，称为合成。

**2）什么是合成**

​ 合成是一种技术，可以将页面的各个部分分成图层，分别将它们光栅化，然后在称为合成器线程的单独线程中合成为页面。如果发生滚动，由于图层已经被光栅化，它所要做的就是合成一个新的帧。可以通过移动图层并合成新帧以相同的方式实现动画。

**3）分层**

​ 为了找出哪些元素需要在哪些层中，主线程遍历布局树来创建层树（这部分在 DevTools 性能面板中称为“Update Layer Tree”）。如果页面的某些部分应该是单独的层（如滑入式侧边菜单），可以通过使用`will-change`CSS 中的属性来提示浏览器。

**4）主线程的光栅和合成**

​ 一旦创建了层树并确定了绘制顺序，主线程就会将该信息提交给合成器线程。合成器线程然后光栅化每一层。一个层可能像一页的整个长度一样大，因此合成器线程将它们分成小块并将每个小块发送到光栅线程。光栅线程光栅化每个图块并将它们存储在 GPU 内存中。

​ 合成器线程可以优先考虑不同的光栅线程，以便可以首先对视口（或附近）内的事物进行光栅化。一个图层还具有针对不同分辨率的多个平铺，以处理诸如放大操作之类的事情。

​ 一旦瓦片被光栅化，合成器线程收集称为**绘制四边形**的瓦片信息以创建**合成器框架**。

​ 然后通过 IPC 将合成器框架提交给浏览器进程。此时，可以从 UI 线程添加另一个合成器框架以更改浏览器 UI，或从其他渲染器进程添加用于扩展。这些合成器帧被发送到 GPU 以在屏幕上显示。如果出现滚动事件，合成器线程会创建另一个合成器帧以发送到 GPU。

​ 合成的好处是它是在不涉及主线程的情况下完成的。合成器线程不需要等待样式计算或 JavaScript 执行。

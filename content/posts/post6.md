---

title: 浏览器工作原理
date: 2022-07-31
---​

### 一、现代浏览器的架构

​ 简而言之，可能是一个多线程的进程，也可能是多个进程，其中有几个线程通过 IPC 进行通信。那具体的架构就是各个浏览器的实现细节了，没有关于如何构建 Web 浏览器的标准规范。一种浏览器的方法可能与另一种完全不同。那作为前端开发最常见的浏览器，我们将以谷歌浏览器作为例子进行介绍。

​ 在架构的最顶层是浏览器进程，主要用于协调不同部分的其他进程；接着是渲染器进程，该进程会创建多个进程并将其分配给每个选项卡。最近，Chrome 还在可能的情况下为每个选项卡提供了一个进程；现在它尝试为每个站点提供自己的进程，包括 iframe

### 二、各个进程的功能与作用

| 进程                          | 功能与作用                                                                                                                  |
| ----------------------------- | --------------------------------------------------------------------------------------------------------------------------- |
| 浏览器进程（Browser Process） | 控制应用程序的“chrome”部分，包括地址栏、书签、后退和前进按钮。 还处理网络浏览器中不可见的特权部分，例如网络请求和文件访问。 |
| 渲染进程（Renderer Process）  | 控制显示网站的选项卡内的任何内容。                                                                                          |
| 插件进程（Plugin Process）    | 控制网站使用的任何插件，例如 Flash。                                                                                        |
| 图形处理进程（GPU Process）   | 与其他进程隔离处理 GPU 任务。它被分成不同的进程，因为 GPU 处理来自多个应用程序的请求并将它们绘制在同一个表面上。            |

### 三、多进程的好处

​ 我们现在了解到， Chrome 使用多个渲染进程。在最简单的情况下，每个选项卡都有自己的渲染器进程。假设我们打开了 3 个选项卡，每个选项卡都由一个独立的渲染器进程运行。如果一个选项卡无响应，那么我们可以关闭无响应的选项卡并继续前进，同时保持其他选项卡处于活动状态。如果所有选项卡都在一个进程上运行，则当一个选项卡无响应时，所有选项卡均无响应，就会比较尴尬。

​ 将浏览器的工作分成多个进程的另一个好处是安全性和沙盒。由于操作系统提供了一种限制进程权限的方法，因此浏览器可以对某些进程的某些功能进行沙箱处理。例如，Chrome 浏览器限制处理任意用户输入的进程（如渲染器进程）的任意文件访问。

​ 因为进程有自己的私有内存空间，它们通常包含通用基础设施的副本（例如 V8，它是 Chrome 的 JavaScript 引擎）。这意味着更多的内存使用，因为它们不能像在同一进程中的线程那样共享。为了节省内存，Chrome 限制了它可以启动的进程数。限制取决于设备拥有多少内存和 CPU 能力，但是当 Chrome 达到限制时，它会开始在一个进程中运行来自同一站点的多个选项卡。

### 四、当我们在地址栏键入 URL 之后，整个过程是怎样的？

​ 经典的前端面试问题，我们不妨通过 chrome 的整个架构，从浏览器的角度，来看看这个过程究竟会发生哪些事情。

​ 第二节有提到选项卡之外的所有内容都由浏览器进程处理。浏览器进程具有诸如绘制浏览器按钮和输入字段的 UI 线程、处理网络堆栈以从 Internet 接收数据的网络线程、控制对文件的访问的存储线程等线程。当我们在地址栏中键入 URL 时，我们的输入由浏览器进程的 UI 线程处理。

#### 1、处理输入

​ 当我们开始在地址栏中输入内容时，UI 线程询问的第一件事是“这是搜索查询还是 URL？”。在 Chrome 中，地址栏也是一个搜索输入字段，因此 UI 线程需要解析并决定是将我们本次的输入发送到搜索引擎还是我们要请求的站点。

#### 2、导航

​ 当我们按下回车时，UI 线程会发起网络调用以获取站点内容。加载微调器显示在选项卡的一角，网络线程通过适当的协议，如 DNS 查找和为请求建立 TLS 连接。此时，网络线程可能会收到 HTTP 301 之类的服务器重定向标头。在这种情况下，网络线程会与服务器正在请求重定向的 UI 线程通信。然后，将发起另一个 URL 请求。具体的整个网络中的一些传输知识，如 DNS 解析，TCP 建立连接等等就省略了，我们主要关注在浏览器着一层的一些内容。

#### 3、解析响应结果

​ 一旦响应主体（有效负载）开始进入，网络线程会在必要时查看流的前几个字节。响应的 Content-Type 标头应该说明它是什么类型的数据，但由于它可能丢失或错误，因此在这里进行 MIME 类型判断，这个不过多赘述。如果响应是一个 HTML 文件，那么下一步就是将数据传递给渲染器进程，但如果它是一个 zip 文件或其他文件，那么这意味着它是一个下载请求，所以他们需要将数据传递给下载管理器。这也是进行安全浏览检查的地方。如果域和响应数据似乎与已知的恶意站点相匹配，则网络线程会发出警报以显示警告页面。

#### 4、查找渲染进程

​ 一旦完成所有检查并且网络线程确信浏览器应该导航到请求的站点，网络线程就会告诉 UI 线程数据已准备好。UI 线程然后找到一个渲染器进程来进行网页的渲染。由于网络请求可能需要数百毫秒才能得到响应，因此对此过程会进行优化。当 UI 线程在第 2 步向网络线程发送 URL 请求时，它已经知道他们正在导航到哪个站点。UI 线程尝试主动查找或启动与网络请求并行的渲染器进程。这样，如果一切按预期进行，当网络线程接收到数据时，渲染器进程已经处于待机位置。如果导航重定向跨站点，则可能不会使用此备用进程，在这种情况下，可能需要不同的进程。

#### 5、提交导航

​ 现在数据和渲染器进程已准备就绪，从浏览器进程向渲染器进程发送 IPC 以提交导航。它还传递数据流，因此渲染器进程可以继续接收 HTML 数据。一旦浏览器进程听到在渲染器进程中发生提交的确认，导航就完成了，文档加载阶段开始了。

​ 此时，地址栏更新，安全指示器和站点设置 UI 反映了新页面的站点信息。该选项卡的会话历史记录将被更新，因此后退/前进按钮将逐步浏览刚刚导航到的站点。为了在我们关闭选项卡或窗口时促进选项卡/会话恢复，会话历史记录存储在磁盘上。

#### 5.1、额外步骤：初始加载完成

​ 提交导航后，渲染器进程会继续加载资源并渲染页面。那在之后再详细介绍此阶段发生的事情。一旦渲染器进程“完成”渲染，它会将 IPC 发送回浏览器进程（这是在`onload`页面中的所有帧上触发所有事件并完成执行之后）。此时，UI 线程停止选项卡上的加载微调器。这里之所以说“完成”，是因为在此之后客户端的 JavaScript 仍然可以加载额外的资源并呈现新视图。

### 五、跳转/导航到其他站点

​ 如果我们再次将不同的 URL 放到地址栏会发生什么呢？浏览器进程会通过相同的步骤导航到不同的站点。但在此之前，它需要检查当前呈现的站点是否有注册`beforeunload`事件。

​ `beforeunload`可以在我们尝试离开或关闭选项卡时创建“离开此站点？”类似的警报。选项卡内的所有内容，包括我们写的 JavaScript 代码，都由渲染器进程处理，因此当新的导航请求进来时，浏览器进程必须检查当前的渲染器进程。

​ 如果导航是从渲染器进程启动的（例如单击链接或客户端 JavaScript 已运行`window.location = "https://newsite.com"`），则渲染器进程首先检查`beforeunload`处理程序。然后，它经历与浏览器进程启动导航相同的过程。唯一的区别是导航请求是从渲染器进程启动到浏览器进程的。

​ 当新导航指向与当前呈现的站点不同的站点时，会调用一个单独的呈现进程来处理新的导航，而当前的呈现进程会被保留以处理诸如`unload`的事件。
